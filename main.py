# -*- coding: utf-8 -*-
"""main.py

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/17-re6n5eLHtkN9WsSkSe-v2wDYQB9U1W
"""

import pandas as pd
import joblib
from fastapi import FastAPI, HTTPException
from pydantic import BaseModel
import numpy as np
import os

app = FastAPI(title="Courtside Alpha Multi-Stat Engine")

# --- 1. CONFIGURACIÓN DE MODELOS ---
# Mapeamos el nombre lógico al nombre del archivo real
MODEL_FILES = {
    "pts": "nba_model_pts_model.pkl",
    "ast": "nba_model_ast_model.pkl",
    "reb": "nba_model_reb_model.pkl",
    "blk": "nba_model_blk_model.pkl",
    "stl": "nba_model_stl_model.pkl"
}

loaded_models = {}

# Carga masiva al iniciar la app
print("--- INICIANDO CARGA DE MODELOS ---")
for stat_name, filename in MODEL_FILES.items():
    try:
        if os.path.exists(filename):
            loaded_models[stat_name] = joblib.load(filename)
            print(f"✅ Modelo cargado: {stat_name.upper()} ({filename})")
        else:
            print(f"⚠️ Archivo no encontrado: {filename}")
    except Exception as e:
        print(f"❌ Error cargando {filename}: {e}")

# --- 2. DATA SCHEMAS ---
class PredictionRequest(BaseModel):
    player_name: str
    opponent: str
    is_home: bool = True

# --- 3. MOCK DATA BASE (Promedios 2024-25 para Feature Engineering) ---
# Necesitamos promedios base para que el modelo tenga un punto de partida
PLAYER_BASE_STATS = {
    "LeBron James":  {"avg_pts": 25.4, "avg_ast": 8.1, "avg_reb": 7.3, "avg_blk": 0.6, "avg_stl": 1.1, "momentum": 1.05},
    "Stephen Curry": {"avg_pts": 28.1, "avg_ast": 5.0, "avg_reb": 4.4, "avg_blk": 0.3, "avg_stl": 0.8, "momentum": 0.98},
    "Luka Doncic":   {"avg_pts": 33.9, "avg_ast": 9.8, "avg_reb": 9.2, "avg_blk": 0.5, "avg_stl": 1.4, "momentum": 1.10},
    "Nikola Jokic":  {"avg_pts": 26.4, "avg_ast": 9.0, "avg_reb": 12.4, "avg_blk": 0.9, "avg_stl": 1.2, "momentum": 1.02},
    "Jayson Tatum":  {"avg_pts": 27.1, "avg_ast": 4.9, "avg_reb": 8.1, "avg_blk": 0.6, "avg_stl": 1.0, "momentum": 1.00},
    # Fallback genérico
    "DEFAULT":       {"avg_pts": 15.0, "avg_ast": 3.0, "avg_reb": 4.0, "avg_blk": 0.4, "avg_stl": 0.7, "momentum": 1.0}
}

OPPONENT_STATS = {
    "BOS": {"def_rating": 110.5, "pace": 98.2},
    "DEN": {"def_rating": 114.2, "pace": 97.5},
    "LAL": {"def_rating": 115.0, "pace": 101.0},
    "DEFAULT": {"def_rating": 112.0, "pace": 99.0}
}

# --- 4. ENDPOINT DE PREDICCIÓN MASIVA ---
@app.post("/predict_all")
def predict_performance(request: PredictionRequest):
    # A. Recuperar datos base
    player_stats = PLAYER_BASE_STATS.get(request.player_name, PLAYER_BASE_STATS["DEFAULT"])
    opp_stats = OPPONENT_STATS.get(request.opponent, OPPONENT_STATS["DEFAULT"])

    predictions = {}

    # B. Iterar sobre cada estadística y su modelo correspondiente
    for stat, model in loaded_models.items():
        try:
            # IMPORTANTE: Aquí construimos el DataFrame de entrada.
            # Asumo que tus 5 modelos fueron entrenados con las MISMAS columnas de entrada (features).
            # Si cada modelo usó columnas distintas, necesitarás un 'if' aquí para ajustar el input_data.

            # Construimos un vector de características rico
            input_data = pd.DataFrame([{
                'avg_pts': player_stats['avg_pts'], # Incluimos todos los promedios como contexto
                'avg_ast': player_stats['avg_ast'],
                'avg_reb': player_stats['avg_reb'],
                'def_rating': opp_stats['def_rating'],
                'pace': opp_stats['pace'],
                'is_home': 1 if request.is_home else 0,
                'momentum': player_stats['momentum']
            }])

            # NOTA DE ARQUITECTURA:
            # Si tus modelos.pkl esperan columnas estrictas y diferentes entre sí,
            # el código fallará aquí. Asegúrate de que el input_data tenga las columnas
            # exactas que usaste en `model.fit()`.

            # Realizar predicción
            pred_val = model.predict(input_data)

            # Limpieza del valor (extraer de array numpy)
            val = float(pred_val[0]) if isinstance(pred_val[0], (np.float64, float)) else float(pred_val[0][0])
            predictions[stat] = round(val, 1)

        except Exception as e:
            print(f"Error prediciendo {stat}: {e}")
            predictions[stat] = -1 # Valor de error controlado

    # C. Respuesta JSON consolidada
    return {
        "player": request.player_name,
        "opponent": request.opponent,
        "predictions": predictions, # Aquí van los 5 valores: {pts: 25.5, ast: 6.2...}
        "context": {
            "momentum_label": "High" if player_stats['momentum'] > 1.05 else "Normal",
            "matchup_difficulty": "Hard" if opp_stats['def_rating'] < 111 else "Neutral"
        }
    }